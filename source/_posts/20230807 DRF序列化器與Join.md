---
title: 20230807 DRF序列化器與Join（待撰寫）
date: 2023-08-07T08:16:55.971
tag:
  - Django
  - DRF Serializer
updated: 2023-08-07T08:16:55.971
categories:
  - [Django]
---
### 閱讀
- [官方文檔](https://pythondjango.cn/django/rest-framework/1-RESTfull-API-why-DRF/#django%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%BA%8F%E5%88%97%E5%8C%96)
  - [關聯方面的敘述](https://www.django-rest-framework.org/api-guide/relations/)
- [大江狗](https://pythondjango.cn/django/rest-framework/1-RESTfull-API-why-DRF/#django%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%BA%8F%E5%88%97%E5%8C%96)
- 令人苦惱的 涉及join的序列化寫法相關討論 [1](https://stackoverflow.com/questions/66390176/how-to-join-two-related-models-in-one-serializer-in-django) [2](https://stackoverflow.com/questions/67742095/django-rest-framework-cant-join-tables)
- 遇過的例外：
  - [model fields欄位名稱有寫對嗎？](https://stackoverflow.com/questions/36336145/assertionerror-the-field-was-declared-on-serializer-but-has-not-been-i)
  還有另個相似的錯誤，他會提示你fields得是tuple, list或string
  ```py
  # 正確的寫法
  fields = '__all__'
  # 或
  fields = ['item_kinds','desc']
  ```
  - 讓案情逐漸水落石出的例外：ImproperlyConfigured
  - [返回非可迭代類型..](https://www.freecodecamp.org/chinese/news/int-object-is-not-iterable-python-error-solved/) [1](https://stackoverflow.com/questions/60993024/django-object-is-not-iterable-error-when-using-get-method)

***
### 釐清結果
最後又是ChatGPT救了我......
#### ChatGPT的回答
>根据你提供的序列化器，似乎你正在使用Django的REST框架进行API的开发。现在你想要创建一个序列化器来包含记账条目以及与之关联的种类描述。然而，在 AccountsWithKindsMemoSerializer 中，你将 ItemKinds 作为模型使用，这可能是造成问题的地方。
>
>从你的描述来看，你想要创建一个包含记账条目（Account）以及与之关联的种类描述（ItemKinds）的序列化器。正确的做法是在 AccountSerializer 中包含 kind 字段的相关信息，而不是创建一个新的序列化器。


主要是序列化器的關聯關係有沒有主次擺對呢？之前的寫法似乎都反了

弄老半天弄出來應該是這樣才能達成我要的效果：
models.py:
```py
class Account(models.Model): #對多
    id = models.AutoField(primary_key=True)
    item_name = models.CharField(max_length=50)
    date = models.DateField()
    class IorO(models.TextChoices):
        OUTPUT = 'OUTPUT', _('支出')
        INPUT = 'INPUT', _('收入')
    io = models.CharField(
        max_length=6,
        choices=IorO.choices,
        default=IorO.OUTPUT,
    )
    kind = models.ForeignKey('ItemKinds',  on_delete=models.CASCADE)


class ItemKinds(models.Model):
    kind = models.CharField(primary_key=True, max_length=10)
    desc = models.CharField(max_length=24)

# 網路上有些回答說，你需要__str__的方法，事實上不用也可以達到我們要的效果...
```

serializers.py
```py
class AccountsWithKindsMemoSerializer(serializers.ModelSerializer):
    kind_desc = serializers.CharField(source='kind.desc', read_only=True)  # 添加 kind_desc 字段

    class Meta:
        model = Account
        fields = '__all__'

# 有時候有人要你加getXxx也是不用的，也可以達到我們要的效果...
```

views.py:
```py
    # 安心用，完全不影響以下post方法新增記帳
    queryset = Account.objects.all()

    # 新增單條記帳
    def post(self, request, *args, **kwargs):
        data = request.data
        try:
            serializer_class = AccountSerializer
            serializer = serializer_class(data=data)
            serializer.is_valid(raise_exception=True)
            with transaction.atomic():
                serializer.save()
            return ResponseTool.success_json_res({})
        except Exception as e:
            return ResponseTool.exception_json_res(data)
```

get method所有記帳帶有kind中文（desc）的輸出：
```json
{
    "code": "SUCCESS",
    "message": "成功",
    "data": [
        {
            "id": 1,
            "kind_desc": "物品",
            "item_name": "滑鼠",
            "date": "2023-08-06",
            "io": "OUTPUT",
            "kind": "item"
        },
        {
            "id": 2,
            "kind_desc": "物品",
            "item_name": "滑鼠",
            "date": "2023-08-06",
            "io": "OUTPUT",
            "kind": "item"
        },
        {
            "id": 3,
            "kind_desc": "食品",
            "item_name": "咖啡",
            "date": "2023-08-07",
            "io": "OUTPUT",
            "kind": "food"
        },
        {
            "id": 4,
            "kind_desc": "食品",
            "item_name": "咖啡",
            "date": "2023-08-07",
            "io": "OUTPUT",
            "kind": "food"
        },
        {
            "id": 5,
            "kind_desc": "食品",
            "item_name": "咖啡",
            "date": "2023-08-07",
            "io": "OUTPUT",
            "kind": "food"
        },
        {
            "id": 6,
            "kind_desc": "食品",
            "item_name": "咖啡",
            "date": "2023-08-07",
            "io": "OUTPUT",
            "kind": "food"
        },
        {
            "id": 7,
            "kind_desc": "食品",
            "item_name": "咖啡",
            "date": "2023-08-07",
            "io": "OUTPUT",
            "kind": "food"
        }
    ]
}
```
DRF的序列化器跟Spring Data JPA的method查詢或QueryDSL鍊式查詢直接返回物件其實有蠻大的差別，我甚至覺得相對不直覺（但行數確實減少了），需要習慣始能掌握要領Orz|||