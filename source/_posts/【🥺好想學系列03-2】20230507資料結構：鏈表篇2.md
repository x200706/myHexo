---
title: ã€ğŸ¥ºå¥½æƒ³å­¸ç³»åˆ—03-2ã€‘20230507è³‡æ–™çµæ§‹ï¼šéˆè¡¨ç¯‡2
date: 2023-08-01T15:00:00.000+08:00
updated: 
tag: 
  - data structure
categories: 
  - data structure
cover: 
---
### Leetcode Easyå˜—è©¦å€
### â­[234.å›æ–‡é“¾è¡¨](https://leetcode.cn/problems/palindrome-linked-list?envType=study-plan-v2&id=top-100-liked)
- [åè½‰éˆè¡¨ã€åéä¾†éæ­·](https://blog.csdn.net/pluto_rx/article/details/115382854)
  - [å †ç–Š](https://ithelp.ithome.com.tw/articles/10202838)
    - [æ›´è©³ç´°çš„åè½‰æ•™å­¸](https://www.geeksforgeeks.org/program-to-reverse-a-linked-list-using-stack/)
- ä¸éå…¶å¯¦é€™é¡Œç”¨ä¸è‘—åè½‰ï¼Œç›´æ¥è·Ÿstackçš„å…§å®¹ç‰©ç›¸äº’æª¢æŸ¥å³å¯ [æ•™å­¸](https://www.techiedelight.com/zh-tw/determine-linked-list-palindrome-or-not/)

v1ï¼š
```java
     @Test
    public void isPalindromeTest() {
        ListNode head = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(2);
        ListNode node4 = new ListNode(1);

        head.next = node2;
        node2.next = node3;
        node3.next = node4;
        System.out.println(isPalindrome(head));
    }

    public boolean isPalindrome(ListNode head) {
        //æ˜¯ä¸æ˜¯å°ç¨±çš„ï¼Ÿ
        //Stackä¸æ˜¯å…ˆé€²å¾Œå‡ºï¼Ÿå¯ä»¥é‹ç”¨
        Stack<ListNode> stack = new Stack<>();

        //éæ­·éˆè¡¨ï¼ŒæŠŠå®ƒæ¨å…¥å †ç–Š
        ListNode current = head;
        while (current.next != null) { //æ³¨æ„é€™è£¡ï¼Œç›´åˆ°å¾Œä¸€å€‹æ²’æœ‰äº†æ‰åœæ­¢éæ­·
            stack.push(current);
            current = current.next;
        }
        stack.push(current);
        //æ¯”è¼ƒéˆè¡¨è·Ÿå †ç–Šçš„ä¾åºå‡ºç¾çš„å€¼æ˜¯å¦ä¸å»åˆ
        //æŠŠéˆè¡¨æŒ‡é‡æŒ‡å›é ­ é‡æ–°éæ­·
        current = head;
        while (current.next != null) {
            if (stack.pop().val != current.val) {
                return false;
            }
            current = current.next;
        }
        return true;
    }

    public class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }
```
â¬†ï¸v1æ€è·¯ï¼šä½¿ç”¨å †ç–Šå…ˆé€²å¾Œå‡ºçš„ç‰¹æ€§ï¼Œç”¢ç”Ÿåéä¾†çš„éˆè¡¨å»æ¯”å°

### â­[141.ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&id=top-100-liked)
- å¤§å¤§å¸¶ä½ é£›[å¿«æ…¢æŒ‡é‡](https://hackmd.io/@Hsins/fast-slow-pointers)

v1ï¼š
```java
    @Test
    public void hasCycleTest() {
        ListNodeForHasCycle head = new ListNodeForHasCycle(3);
        ListNodeForHasCycle node2 = new ListNodeForHasCycle(2);
        ListNodeForHasCycle node3 = new ListNodeForHasCycle(0);
        ListNodeForHasCycle node4 = new ListNodeForHasCycle(-4);

        head.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node2;
        System.out.println(hasCycle(head));

    }

    public boolean hasCycle(ListNodeForHasCycle head) {
        //ä½¿ç”¨å¿«æ…¢æŒ‡é‡ï¼Œè¢«å€’è¿½ï¼ˆç›¸ç­‰ï¼‰æ™‚å³è¿”å›true
        //éæ­·éˆè¡¨
        ListNodeForHasCycle fast = head;
        ListNodeForHasCycle slow = head;
        while (fast != null && fast.next != null) { //é€™å¥æ˜¯èªªï¼Œç•¶fastæœ¬èº«ä¸æ˜¯nullï¼Œfast.nextä¹Ÿä¸æ˜¯æ™‚ï¼ŒæŒçºŒå¾ªç’°ï¼Œä¹Ÿå°±æ˜¯èªª é€™æ˜¯ä¸€å€‹ç’°ç‹€éˆè¡¨æ‰èƒ½æˆç«‹
            fast = fast.next.next;
            slow = slow.next;
            if(fast==slow){
                return true;
            }
        }

        return false;
    }

    @Test
    public void printTheLinkedList() {
        //é ­æ’æ³•ç·´ç¿’
        ListNodeForHasCycle head = new ListNodeForHasCycle(1);
        ListNodeForHasCycle node2 = new ListNodeForHasCycle(2);
        ListNodeForHasCycle node3 = new ListNodeForHasCycle(5);
        ListNodeForHasCycle node4 = new ListNodeForHasCycle(3);

        head.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = head; //ç’°å½¢éˆè¡¨ï¼Œå°¾å·´å°‡æ¥çºŒé ­éƒ¨

        //æ‰“å°ç·´ç¿’
        ListNodeForHasCycle current = head;
        while (true) {
            System.out.println(current.val);
            if (current.next == head) {
                break;
            }
            current = current.next;
        }
    }

    class ListNodeForHasCycle {
        int val;
        ListNodeForHasCycle next;

        ListNodeForHasCycle(int x) {
            val = x;
            next = null;
        }
    }
```
â¬†ï¸v1æ€è·¯ï¼šå…¶å¯¦ä¹‹å‰å·²ç¶“è¢«é¡Œé€éäº†ï¼Œæ‰€ä»¥å¤§æ¦‚çŸ¥é“å¾—ç”¨å¿«æ…¢æŒ‡é‡ï¼Œä¸éä¹Ÿæ˜¯ä»Šå¤©æ‰çœŸçš„å­¸æœƒæ“ä½œéˆè¡¨ï¼Ÿï¼

v1æ™‚é–“è¤‡é›œåº¦ï¼šå•é¡Œä¾†äº†ï¼Œwhileçš„æ™‚é–“è¤‡é›œåº¦æ˜¯`ï¼Ÿ`
- [whileå¾ªç¯çš„æ—¶é—´å¤æ‚åº¦_æ•°æ®ç»“æ„ä¸ç®—æ³•ï¼šç®—æ³•çš„æ—¶é—´å¤æ‚åº¦](https://blog.csdn.net/weixin_39805195/article/details/113324427)